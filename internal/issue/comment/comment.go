package comment

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

	"prcommenter/internal/common"

	"github.com/google/go-github/github"
)

type Commenter struct {
	client    GitHubClient
	messageId string
}

type GitHubClient interface {
	CreateComment(ctx context.Context, owner string, repo string, number int, comment *github.IssueComment) (*github.IssueComment, *github.Response, error)
	ListComments(ctx context.Context, owner string, repo string, number int, opts *github.IssueListCommentsOptions) ([]*github.IssueComment, *github.Response, error)
	EditComment(ctx context.Context, owner, repo string, commentID int64, comment *github.IssueComment) (*github.IssueComment, *github.Response, error)
}

func NewCommenter(client GitHubClient) *Commenter {
	// Create a unique "id" embedded in the comment that identifies the comment generated by this pipeline+job
	// The generated "id" is unique to the specific pipeline+job, with the plugin message-id param allowing further uniqueness
	messageId := fmt.Sprintf("%s:%s:pr-commenter-buildkite-plugin", os.Getenv("BUILDKITE_PIPELINE_SLUG"), os.Getenv("BUILDKITE_LABEL"))
	uniqueId, found := os.LookupEnv(common.PluginPrefix + "MESSAGE_ID")
	if found {
		messageId = fmt.Sprintf("%s:%s", messageId, uniqueId)
	}

	return &Commenter{
		client:    client,
		messageId: messageId,
	}
}

func (c *Commenter) formatBody(message string) string {
	return fmt.Sprintf("%s\n\n<!-- %s -->", message, c.messageId)
}

func (c *Commenter) Post(ctx context.Context, owner string, repo string, number string, message string) error {
	numberConverted, err := strconv.Atoi(number)
	if err != nil {
		return err
	}

	if message == "" {
		return errors.New("no message provided for comment")
	}
	body := c.formatBody(message)

	comment := &github.IssueComment{
		Body: &body,
	}

	_, _, err = c.client.CreateComment(ctx, owner, repo, numberConverted, comment)
	return err
}

func (c *Commenter) UpdateComment(ctx context.Context, owner string, repo string, message string, commentId int64) error {
	if message == "" {
		return errors.New("no message provided for comment")
	}
	body := c.formatBody(message)
	comment := &github.IssueComment{
		Body: &body,
	}

	_, _, err := c.client.EditComment(ctx, owner, repo, commentId, comment)
	return err
}

func (c *Commenter) FindExistingComment(ctx context.Context, owner string, repo string, number string) (*github.IssueComment, error) {
	numberConverted, err := strconv.Atoi(number)
	if err != nil {
		return nil, err
	}

	comments, _, err := c.client.ListComments(ctx, owner, repo, numberConverted, nil)
	if err != nil {
		return nil, err
	}
	for _, comment := range comments {
		if comment.Body != nil && strings.Contains(*comment.Body, c.messageId) {
			return comment, nil
		}
	}
	return nil, nil
}

func (c *Commenter) MatchBody(ctx context.Context, comment *github.IssueComment, message string) bool {
	// Match for exact body content
	return c.formatBody(message) == *comment.Body
}
